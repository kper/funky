use std::str::FromStr;
use crate::ir::ast::*;

grammar;

Comma<T>: Vec<T> = { 
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Program : Program = {
   <functions:Function*> => Program {
       functions: functions
   } 
};

pub Function : Function = {
    "define" <name:Id> "(result" <result:Num> ")" "(define" <def:Reg*> ")" "{" <instr:Instruction*>  "}" ";" => {
        Function {
            name,
            params: Vec::new(),
            definitions: def,
            results_len: result as usize,
            instructions: instr.into_iter().flatten().collect::<Vec<_>>()
        }
    },
    "define" <name:Id> "(param" <reg:Reg*> ")" "(result" <result:Num> ")" "(define" <def:Reg*> ")" "{" <instr:Instruction*>  "}" ";" => {
        Function {
            name,
            params: reg,
            definitions: def,
            results_len: result as usize,
            instructions: instr.into_iter().flatten().collect::<Vec<_>>()
        }
    },
    "define" <name:Name> "(result" <result:Num> ")" "(define" <def:Reg*> ")" "{" <instr:Instruction*>  "}" ";" => {
        Function {
            name,
            params: Vec::new(),
            definitions: def,
            results_len: result as usize,
            instructions: instr.into_iter().flatten().collect::<Vec<_>>()
        }
    },
    "define" <name:Name> "(param" <reg:Reg*> ")" "(result" <result:Num> ")" "(define" <def:Reg*> ")" "{" <instr:Instruction*>  "}" ";" => {
        Function {
            name,
            params: reg,
            definitions: def,
            results_len: result as usize,
            instructions: instr.into_iter().flatten().collect::<Vec<_>>()
        }
    }
};

pub Instruction : Vec<Instruction> = {
    "BLOCK" <n:Id> => vec![Instruction::Block(n)],
    <dest:Reg> "=" <src:Reg> => vec![Instruction::Assign(dest, src)],
    <dest:Reg> "=" <n:Num> => vec![Instruction::Const(dest, n)],
    <dest:Reg> "=" "op" <src:Reg> => vec![Instruction::Unop(dest, src)],
    <dest:Reg> "=" <src1:Reg> "op" <src2:Reg> => vec![Instruction::BinOp(dest, src1, src2)],
    "GOTO" <n:Id> => vec![Instruction::Jump(n)],
    "IF" <reg:Reg> "THEN" "GOTO" <n:Id> "ELSE" "GOTO" <n2:Id> => {
        vec![Instruction::Conditional(reg, vec![n, n2])]
    },
    "IF" <reg:Reg> "THEN" "GOTO" <n:Id> => {
        vec![Instruction::Conditional(reg, vec![n])]
    },
    "TABLE GOTO" <n:Id*> "ELSE" "GOTO" <n2:Id> => {
        let mut n = n.clone();
        n.push(n2);
        vec![Instruction::Table(n)]
    },
    "KILL" <reg:Reg> => vec![Instruction::Kill(reg)],
    "CALL" <n:Name> "(" <r:Reg*> ")" => vec![Instruction::Call(n, r, vec![])],
    <dest:Reg*> "<-" "CALL" <n:Name> "(" <r:Reg*> ")" => vec![Instruction::Call(n, r, dest)],
    "CALL" <n:Id> "(" <r:Reg*> ")" => vec![Instruction::Call(n, r, vec![])],
    <dest:Reg*> "<-" "CALL" <n:Id> "(" <r:Reg*> ")" => vec![Instruction::Call(n, r, dest)],
    "RETURN" <n:Reg*> ";" => {
        vec![Instruction::Return(n)]
    }
};

Id : String = {
    <n:Num> => (n as usize).to_string()
};

pub Reg: String = {
    "%" <n:Num> => format!("%{}", n),
    "%" <n:Name> => format!("%{}", n),
};

pub Num: f64 = <s:r"[+-]?[0-9]*[.,]?[0-9]+"> => f64::from_str(s).unwrap();
pub Name: String = <s:r"[a-zA-Z]+"> => s.to_string();